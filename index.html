<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Market DAO</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- React and ReactDOM from CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX transformation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .proposal-card {
      border-left-width: 4px !important;
    }
    .badge-resolution {
      background-color: #f3e5f5;
      color: #4a148c;
    }
    .badge-treasury {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    .badge-mint {
      background-color: #fff3e0;
      color: #e65100;
    }
    .badge-price {
      background-color: #e3f2fd;
      color: #0d47a1;
    }
  </style>
</head>
<body>
  <div id="root" class="container py-4" style="max-width: 900px;"></div>

  <!-- Bootstrap JS Bundle with Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

  <script type="text/babel">
    // Constants with actual addresses from the Polygon Amoy testnet deployment
    const DAO_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3';
    const FACTORY_ADDRESS = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512';
    
    // Helper function to safely convert BigNumber to string
    const safeValue = (value) => {
      if (value === undefined || value === null) return '0';
      if (typeof value === 'object' && value._isBigNumber) return value.toString();
      return String(value);
    };
    
    // Helper for safe ETH formatting
    const safeFormatEther = (value) => {
      try {
        if (typeof value === 'object' && value._isBigNumber) {
          return ethers.utils.formatEther(value);
        } else if (typeof value === 'string' && value.match(/^[0-9]+$/)) {
          return ethers.utils.formatEther(value);
        }
        return value;
      } catch (error) {
        console.error('Error formatting ether value:', error, value);
        return value;
      }
    };
    
    // Main App Component
    function App() {
      const [activeTab, setActiveTab] = React.useState('dashboard');
      const [isConnected, setIsConnected] = React.useState(false);
      const [walletAddress, setWalletAddress] = React.useState('');
      const [purchaseAmount, setPurchaseAmount] = React.useState(1);
      const [proposalType, setProposalType] = React.useState('resolution');
      const [proposalDescription, setProposalDescription] = React.useState('');
      const [proposals, setProposals] = React.useState([]);
      
      // Treasury proposal state
      const [treasuryData, setTreasuryData] = React.useState({
        description: '',
        recipient: '',
        amount: '',
        tokenType: 'eth',
        tokenAddress: '',
        tokenId: ''
      });
      
      // Mint proposal state
      const [mintData, setMintData] = React.useState({
        description: '',
        recipient: '',
        amount: ''
      });
      
      // Token price proposal state
      const [priceData, setPriceData] = React.useState({
        description: '',
        newPrice: ''
      });
      
      const [daoInfo, setDaoInfo] = React.useState({
        name: 'Loading...',
        tokenBalance: '0',
        vestedBalance: '0',
        unvestedBalance: '0',
        tokenSupply: '0',
        tokenPrice: '0',
        quorumPercentage: '0',
        supportThreshold: '0',
        treasuryBalance: '0',
        vestingPeriod: '0'
      });
      const [electionProposals, setElectionProposals] = React.useState([]);
      const [historyProposals, setHistoryProposals] = React.useState([]);
      const [notification, setNotification] = React.useState({
        show: false,
        message: '',
        type: ''
      });
      const [isLoading, setIsLoading] = React.useState(false);
      
      // Store references to ethers.js objects
      const providerRef = React.useRef(null);
      const signerRef = React.useRef(null);
      const daoContractRef = React.useRef(null);
      const factoryContractRef = React.useRef(null);
      
      // Add a cache for proposal data to reduce RPC calls
      const proposalCacheRef = React.useRef({});
      const proposalListRef = React.useRef([]);
      const dataLoadedRef = React.useRef(false);
      
      // Define Proposal ABIs
      const baseProposalAbi = [
        "function description() view returns (string)",
        "function proposer() view returns (address)",
        "function createdAt() view returns (uint256)",
        "function supportTotal() view returns (uint256)",
        "function electionTriggered() view returns (bool)",
        "function executed() view returns (bool)",
        "function electionStart() view returns (uint256)",
        "function votingTokenId() view returns (uint256)",
        "function yesVoteAddress() view returns (address)",
        "function noVoteAddress() view returns (address)",
        "function isElectionActive() view returns (bool)",
        "function checkEarlyTermination()",
        "function dao() view returns (address)"
      ];
      
      const treasuryProposalAbi = baseProposalAbi.concat([
        "function recipient() view returns (address)",
        "function amount() view returns (uint256)",
        "function token() view returns (address)",
        "function tokenId() view returns (uint256)"
      ]);
      
      const mintProposalAbi = baseProposalAbi.concat([
        "function recipient() view returns (address)",
        "function amount() view returns (uint256)"
      ]);
      
      const tokenPriceProposalAbi = baseProposalAbi.concat([
        "function newPrice() view returns (uint256)"
      ]);
      
      // Global error handler for unexpected errors
      React.useEffect(() => {
        const errorHandler = (event) => {
          console.error('Unhandled error:', event.error || event.reason);
          showNotification('An unexpected error occurred. Check console for details.', 'danger');
        };
        
        window.addEventListener('error', errorHandler);
        window.addEventListener('unhandledrejection', errorHandler);
        
        return () => {
          window.removeEventListener('error', errorHandler);
          window.removeEventListener('unhandledrejection', errorHandler);
        };
      }, []);
      
      // Lazy loading effect - load data based on active tab
      React.useEffect(() => {
        if (isConnected && dataLoadedRef.current) {
          switch (activeTab) {
            case 'dashboard':
              // No additional data needed for dashboard
              break;
            case 'proposals':
              updateActiveProposals();
              break;
            case 'elections':
              updateElectionProposals();
              break;
            case 'history':
              updateHistoryProposals();
              break;
            default:
              break;
          }
        }
      }, [activeTab, isConnected]);
      
      // Show notification helper
      const showNotification = (message, type = 'info') => {
        setNotification({
          show: true,
          message,
          type
        });
        
        setTimeout(() => {
          setNotification({
            show: false,
            message: '',
            type: ''
          });
        }, 3000);
      };
      
      // Optimized function to fetch a single proposal's details with caching
      const fetchProposalDetails = async (proposalAddress) => {
        // Check cache first
        if (proposalCacheRef.current[proposalAddress]) {
          return proposalCacheRef.current[proposalAddress];
        }
        
        try {
          // Use the existing signer instead of creating a new one to avoid connection issues
          
          const baseContract = new ethers.Contract(
            proposalAddress,
            baseProposalAbi,
            signerRef.current
          );
          
          // Get common proposal details in a single batch
          const [
            description, 
            proposer, 
            createdAt, 
            supportTotal, 
            electionTriggered, 
            executed,
            electionStart
          ] = await Promise.all([
            baseContract.description(),
            baseContract.proposer(),
            baseContract.createdAt(),
            baseContract.supportTotal(),
            baseContract.electionTriggered(),
            baseContract.executed(),
            baseContract.electionStart()
          ]);
          
          let proposalData = {
            address: proposalAddress,
            description,
            proposer,
            createdAt: createdAt.toString(),
            supportTotal: supportTotal.toString(),
            electionTriggered,
            executed,
            electionStart: electionStart.toString(),
            type: 'resolution', // Default type, will be overridden if necessary
            details: {},
            isHistorical: executed, // Default - will be updated for elections
            votes: { yes: '0', no: '0', total: '0', available: '0' },
            votingTokenId: '0',
            electionStatus: 'Unknown',
            isActive: false,
            result: executed ? 'EXECUTED' : ''
          };
          
          // If it's an election, get the voting details
          if (electionTriggered) {
            const [votingTokenId, yesVoteAddress, noVoteAddress] = await Promise.all([
              baseContract.votingTokenId(),
              baseContract.yesVoteAddress(),
              baseContract.noVoteAddress()
            ]);
            
            proposalData.votingTokenId = votingTokenId.toString();
            
            // Get vote counts
            const [yesVotes, noVotes, totalVotes, userVotingBalance] = await Promise.all([
              daoContractRef.current.balanceOf(yesVoteAddress, votingTokenId),
              daoContractRef.current.balanceOf(noVoteAddress, votingTokenId),
              daoContractRef.current.totalSupply(votingTokenId),
              daoContractRef.current.balanceOf(walletAddress, votingTokenId)
            ]);
            
            proposalData.votes = {
              yes: yesVotes.toString(),
              no: noVotes.toString(),
              total: totalVotes.toString(),
              available: userVotingBalance.toString()
            };
            
            // Check if election is active
            try {
              const currentBlock = await providerRef.current.getBlockNumber();
              const daoContract = new ethers.Contract(
                await baseContract.dao(),
                ["function electionDuration() view returns (uint256)"],
                signerRef.current
              );
              const electionDuration = await daoContract.electionDuration();
              const electionEnd = electionStart.add(electionDuration);
              
              // Determine election status
              if (currentBlock < parseInt(electionStart.toString())) {
                proposalData.electionStatus = "Not Started";
                proposalData.isActive = false;
              } else if (currentBlock >= parseInt(electionEnd.toString())) {
                proposalData.electionStatus = "Ended";
                proposalData.isActive = false;
                
                // If election has ended but not executed, it's historical
                if (!executed) {
                  proposalData.isHistorical = true;
                  
                  // Determine result
                  const quorumPercentage = await daoContractRef.current.quorumPercentage();
                  const quorum = totalVotes.mul(quorumPercentage).div(100);
                  
                  // Check if quorum was met
                  if (yesVotes.add(noVotes).lt(quorum)) {
                    proposalData.result = 'REJECTED (Quorum not met)';
                  } else if (yesVotes.gt(noVotes)) {
                    proposalData.result = 'APPROVED';
                  } else {
                    proposalData.result = 'REJECTED';
                  }
                }
              } else {
                proposalData.electionStatus = "Active";
                proposalData.isActive = true;
              }
            } catch (error) {
              console.warn(`Error checking election status for ${proposalAddress}:`, error);
              proposalData.electionStatus = "Error";
              proposalData.isActive = false;
            }
          }
          
          // Try to determine proposal type (in parallel with election check)
          try {
            // Check if it's a treasury proposal
            const treasuryContract = new ethers.Contract(
              proposalAddress,
              treasuryProposalAbi,
              signerRef.current
            );
            
            const recipient = await treasuryContract.recipient();
            
            // If we get here without error, it's a treasury proposal
            const [amount, token, tokenId] = await Promise.all([
              treasuryContract.amount(),
              treasuryContract.token(),
              treasuryContract.tokenId()
            ]);
            
            proposalData.type = 'treasury';
            proposalData.details = {
              recipient,
              amount: amount.toString(),
              token,
              tokenId: tokenId.toString()
            };
          } catch (e) {
            // Not a treasury proposal, try mint
            try {
              const mintContract = new ethers.Contract(
                proposalAddress,
                mintProposalAbi,
                signerRef.current
              );
              
              const recipient = await mintContract.recipient();
              
              // If we get here without error, it's a mint proposal
              const amount = await mintContract.amount();
              
              proposalData.type = 'mint';
              proposalData.details = {
                recipient,
                amount: amount.toString()
              };
            } catch (e) {
              // Not a mint proposal, try token price
              try {
                const priceContract = new ethers.Contract(
                  proposalAddress,
                  tokenPriceProposalAbi,
                  signerRef.current
                );
                
                const newPrice = await priceContract.newPrice();
                
                // If we get here without error, it's a price proposal
                proposalData.type = 'price';
                proposalData.details = {
                  newPrice: newPrice.toString()
                };
              } catch (e) {
                // Must be a resolution proposal (already set as default)
              }
            }
          }
          
          // Cache the result
          proposalCacheRef.current[proposalAddress] = proposalData;
          return proposalData;
        } catch (error) {
          console.error(`Error fetching proposal details for ${proposalAddress}:`, error);
          return null;
        }
      };
      
      // Optimized function to load all proposals with robust error handling
      const loadAllProposals = async () => {
        try {
          setIsLoading(true);
          
          if (!factoryContractRef.current || !signerRef.current) {
            console.warn("Factory contract or signer not available");
            setIsLoading(false);
            return;
          }
          
          showNotification('Loading proposal data...', 'info');
          
          let count;
          try {
            // Get proposal count with retry logic
            for (let attempt = 0; attempt < 3; attempt++) {
              try {
                count = await factoryContractRef.current.proposalCount();
                break;
              } catch (err) {
                console.warn(`Attempt ${attempt + 1} to get proposal count failed:`, err);
                if (attempt === 2) throw err;
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
              }
            }
          } catch (countError) {
            console.error("Failed to get proposal count:", countError);
            setIsLoading(false);
            showNotification('Could not retrieve proposals - network error', 'danger');
            return;
          }
          
          // If we have no proposals or count is zero, show early
          if (!count || count.toNumber() === 0) {
            console.log("No proposals found");
            proposalListRef.current = [];
            dataLoadedRef.current = true;
            updateActiveProposals();
            updateElectionProposals();
            updateHistoryProposals();
            setIsLoading(false);
            showNotification('No proposals found', 'info');
            return;
          }
          
          // For demo/testing - use mock data if the blockchain connection is problematic
          // This ensures the frontend works even without blockchain connectivity
          const useMockDataOnFailure = true;
          let proposalAddresses = [];
          
          try {
            // Create an array of promises to fetch all proposals
            const proposalAddressPromises = [];
            for (let i = count.toNumber() - 1; i >= 0; i--) {
              proposalAddressPromises.push(
                // Wrap each call in a try/catch to prevent a single failure from breaking the whole batch
                (async () => {
                  try {
                    return await factoryContractRef.current.getProposal(i);
                  } catch (e) {
                    console.warn(`Failed to get proposal at index ${i}:`, e);
                    return null;
                  }
                })()
              );
            }
            
            // Get all proposal addresses in parallel
            const results = await Promise.all(proposalAddressPromises);
            proposalAddresses = results.filter(addr => addr !== null);
            
            if (proposalAddresses.length === 0 && useMockDataOnFailure) {
              throw new Error("Failed to retrieve any valid proposal addresses");
            }
          } catch (error) {
            if (useMockDataOnFailure) {
              console.warn("Using mock proposal data due to blockchain connectivity issues:", error);
              // Mock data for display when blockchain is unavailable
              const mockProposals = [
                { 
                  address: '0x1234567890123456789012345678901234567890',
                  description: 'Mock Treasury Proposal',
                  proposer: '0x0000000000000000000000000000000000000001',
                  createdAt: '1000',
                  supportTotal: '10',
                  electionTriggered: false,
                  executed: false,
                  type: 'treasury',
                  details: {
                    recipient: '0x0000000000000000000000000000000000000002',
                    amount: ethers.utils.parseEther('1.0').toString(),
                    token: ethers.constants.AddressZero,
                    tokenId: '0'
                  }
                },
                {
                  address: '0x2345678901234567890123456789012345678901',
                  description: 'Mock Mint Proposal',
                  proposer: '0x0000000000000000000000000000000000000001',
                  createdAt: '2000',
                  supportTotal: '20',
                  electionTriggered: true,
                  executed: false,
                  type: 'mint',
                  details: {
                    recipient: '0x0000000000000000000000000000000000000003',
                    amount: '100'
                  },
                  isActive: true,
                  electionStatus: 'Active',
                  electionStart: '3000',
                  votes: { yes: '30', no: '20', total: '100', available: '5' },
                  votingTokenId: '1'
                },
                {
                  address: '0x3456789012345678901234567890123456789012',
                  description: 'Mock Completed Resolution',
                  proposer: '0x0000000000000000000000000000000000000001',
                  createdAt: '1500',
                  supportTotal: '25',
                  electionTriggered: true,
                  executed: true,
                  type: 'resolution',
                  details: {},
                  isHistorical: true,
                  result: 'APPROVED',
                  votes: { yes: '60', no: '20', total: '100', available: '0' },
                  votingTokenId: '2'
                }
              ];
              
              // Store the mock list
              proposalListRef.current = mockProposals;
              dataLoadedRef.current = true;
              
              // Update the different proposal lists
              updateActiveProposals();
              updateElectionProposals();
              updateHistoryProposals();
              
              setIsLoading(false);
              showNotification('Using sample proposals due to network issues', 'warning');
              return;
            } else {
              throw error; // Rethrow if we're not using mock data
            }
          }
          
          // Use a limit for parallel processing to avoid rate limiting
          const BATCH_SIZE = 3;
          const allProposals = [];
          
          // Process proposals in batches with more robust error handling
          for (let i = 0; i < proposalAddresses.length; i += BATCH_SIZE) {
            const batch = proposalAddresses.slice(i, i + BATCH_SIZE);
            
            // Wrap each fetchProposalDetails in its own try/catch to prevent one failure from breaking the batch
            const batchPromises = batch.map(addr => 
              (async () => {
                try {
                  return await fetchProposalDetails(addr);
                } catch (e) {
                  console.warn(`Error fetching details for proposal ${addr}:`, e);
                  return null;
                }
              })()
            );
            
            const batchResults = await Promise.all(batchPromises);
            
            // Filter out nulls (failed fetches)
            const validResults = batchResults.filter(result => result !== null);
            allProposals.push(...validResults);
            
            // Update loading status
            showNotification(`Loading proposals... ${i + batch.length}/${proposalAddresses.length}`, 'info');
          }
          
          if (allProposals.length === 0 && useMockDataOnFailure) {
            throw new Error("Failed to retrieve any valid proposal details");
          }
          
          // Store the full list
          proposalListRef.current = allProposals;
          dataLoadedRef.current = true;
          
          // Update the different proposal lists
          updateActiveProposals();
          updateElectionProposals();
          updateHistoryProposals();
          
          setIsLoading(false);
          showNotification('Proposals loaded successfully!', 'success');
        } catch (error) {
          console.error('Error loading proposals:', error);
          setIsLoading(false);
          showNotification('Error loading proposals: ' + (error.message || error), 'danger');
        }
      };
      
      // Function to update active proposals (non-election, non-executed)
      const updateActiveProposals = () => {
        const filteredProposals = proposalListRef.current.filter(p => 
          !p.executed && !p.electionTriggered
        );
        setProposals(filteredProposals);
      };
      
      // Function to update election proposals
      const updateElectionProposals = () => {
        const filteredProposals = proposalListRef.current.filter(p => 
          !p.executed && p.electionTriggered && (p.electionStatus === "Active" || p.electionStatus === "Not Started")
        );
        setElectionProposals(filteredProposals);
      };
      
      // Function to update history proposals
      const updateHistoryProposals = () => {
        const filteredProposals = proposalListRef.current.filter(p => 
          p.executed || (p.isHistorical && p.electionTriggered)
        );
        setHistoryProposals(filteredProposals);
      };
      
      // Purchase tokens function
      const purchaseTokens = async () => {
        try {
          if (!daoContractRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Get token price from contract 
          const tokenPrice = await daoContractRef.current.tokenPrice();
          
          // Check if token purchases are disabled
          if (tokenPrice.toString() === '0') {
            showNotification('Direct token purchases are disabled', 'danger');
            return;
          }
          
          // Validate amount
          const amount = Number(purchaseAmount);
          if (isNaN(amount) || amount <= 0) {
            showNotification('Please enter a valid amount', 'danger');
            return;
          }
          
          // Calculate total cost
          const totalCost = tokenPrice.mul(amount);
          
          setIsLoading(true);
          showNotification('Submitting transaction...', 'info');
          
          // Execute purchase
          const tx = await daoContractRef.current.purchaseTokens({ value: totalCost });
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          setIsLoading(false);
          showNotification(`Successfully purchased ${amount} tokens!`, 'success');
          
          // Update user's token balance, vested balance, and total supply
          const newBalance = await daoContractRef.current.balanceOf(walletAddress, 0);
          const newVestedBalance = await daoContractRef.current.vestedBalance(walletAddress);
          const newSupply = await daoContractRef.current.totalSupply(0);

          // Create copy of current state without using spread operator
          const updatedDaoInfo = Object.assign({}, daoInfo);
          updatedDaoInfo.tokenBalance = newBalance.toString();
          updatedDaoInfo.vestedBalance = newVestedBalance.toString();
          updatedDaoInfo.unvestedBalance = newBalance.sub(newVestedBalance).toString();
          updatedDaoInfo.tokenSupply = newSupply.toString();
          setDaoInfo(updatedDaoInfo);
          
        } catch (error) {
          console.error('Error purchasing tokens:', error);
          setIsLoading(false);
          showNotification('Failed to purchase tokens: ' + (error.message || error), 'danger');
        }
      };
      
      // Create resolution proposal
      const createResolutionProposal = async () => {
        try {
          if (!factoryContractRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Validate description
          if (!proposalDescription.trim()) {
            showNotification('Please enter a proposal description', 'danger');
            return;
          }
          
          setIsLoading(true);
          showNotification('Creating resolution proposal...', 'info');
          
          // Call the factory contract to create the proposal
          const tx = await factoryContractRef.current.createResolutionProposal(proposalDescription);
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          setIsLoading(false);
          showNotification('Resolution proposal created successfully!', 'success');
          
          // Clear the description field
          setProposalDescription('');
          
          // Reload all proposal data
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error creating resolution proposal:', error);
          setIsLoading(false);
          showNotification('Failed to create proposal: ' + (error.message || error), 'danger');
        }
      };
      
      // Create treasury proposal
      const createTreasuryProposal = async () => {
        try {
          if (!factoryContractRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Validate required fields
          if (!treasuryData.description.trim()) {
            showNotification('Please enter a proposal description', 'danger');
            return;
          }
          
          if (!treasuryData.recipient.trim()) {
            showNotification('Please enter a recipient address', 'danger');
            return;
          }
          
          if (!treasuryData.amount.trim()) {
            showNotification('Please enter an amount', 'danger');
            return;
          }
          
          // Prepare parameters
          let tokenAddress = ethers.constants.AddressZero; // Default for ETH
          let tokenId = 0;
          
          // Handle token type
          if (treasuryData.tokenType !== 'eth') {
            if (!treasuryData.tokenAddress.trim()) {
              showNotification('Please enter a token address', 'danger');
              return;
            }
            tokenAddress = treasuryData.tokenAddress;
            
            if (treasuryData.tokenType === 'erc721' || treasuryData.tokenType === 'erc1155') {
              if (!treasuryData.tokenId.trim()) {
                showNotification('Please enter a token ID', 'danger');
                return;
              }
              tokenId = parseInt(treasuryData.tokenId);
            }
          }
          
          // Convert amount to appropriate format
          const amount = ethers.utils.parseEther(treasuryData.amount);
          
          setIsLoading(true);
          showNotification('Creating treasury proposal...', 'info');
          
          // Call the factory contract to create the proposal
          const tx = await factoryContractRef.current.createTreasuryProposal(
            treasuryData.description,
            treasuryData.recipient,
            amount,
            tokenAddress,
            tokenId
          );
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          setIsLoading(false);
          showNotification('Treasury proposal created successfully!', 'success');
          
          // Clear the form
          setTreasuryData({
            description: '',
            recipient: '',
            amount: '',
            tokenType: 'eth',
            tokenAddress: '',
            tokenId: ''
          });
          
          // Reload all proposal data
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error creating treasury proposal:', error);
          setIsLoading(false);
          showNotification('Failed to create proposal: ' + (error.message || error), 'danger');
        }
      };
      
      // Create mint proposal
      const createMintProposal = async () => {
        try {
          if (!factoryContractRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Validate required fields
          if (!mintData.description.trim()) {
            showNotification('Please enter a proposal description', 'danger');
            return;
          }
          
          if (!mintData.recipient.trim()) {
            showNotification('Please enter a recipient address', 'danger');
            return;
          }
          
          if (!mintData.amount.trim()) {
            showNotification('Please enter an amount', 'danger');
            return;
          }
          
          setIsLoading(true);
          showNotification('Creating mint proposal...', 'info');
          
          // Call the factory contract to create the proposal
          const tx = await factoryContractRef.current.createMintProposal(
            mintData.description,
            mintData.recipient,
            mintData.amount
          );
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          setIsLoading(false);
          showNotification('Mint proposal created successfully!', 'success');
          
          // Clear the form
          setMintData({
            description: '',
            recipient: '',
            amount: ''
          });
          
          // Reload all proposal data
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error creating mint proposal:', error);
          setIsLoading(false);
          showNotification('Failed to create proposal: ' + (error.message || error), 'danger');
        }
      };
      
      // Create token price proposal
      const createTokenPriceProposal = async () => {
        try {
          if (!factoryContractRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Validate required fields
          if (!priceData.description.trim()) {
            showNotification('Please enter a proposal description', 'danger');
            return;
          }
          
          if (priceData.newPrice === '') {
            showNotification('Please enter a new token price', 'danger');
            return;
          }
          
          // Convert new price to wei
          const newPrice = ethers.utils.parseEther(priceData.newPrice);
          
          setIsLoading(true);
          showNotification('Creating token price proposal...', 'info');
          
          // Call the factory contract to create the proposal
          const tx = await factoryContractRef.current.createTokenPriceProposal(
            priceData.description,
            newPrice
          );
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          setIsLoading(false);
          showNotification('Token price proposal created successfully!', 'success');
          
          // Clear the form
          setPriceData({
            description: '',
            newPrice: ''
          });
          
          // Reload all proposal data
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error creating token price proposal:', error);
          setIsLoading(false);
          showNotification('Failed to create proposal: ' + (error.message || error), 'danger');
        }
      };
      
      // Add support to a proposal
      const addSupport = async (proposalAddress) => {
        try {
          if (!signerRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Get the amount from the input field
          const inputField = document.getElementById(`support-amount-${proposalAddress}`);
          if (!inputField) {
            showNotification('Input field not found', 'danger');
            return;
          }
          
          const amount = parseInt(inputField.value);
          if (isNaN(amount) || amount <= 0) {
            showNotification('Please enter a valid amount', 'danger');
            return;
          }
          
          // Create proposal contract instance with the addSupport function
          const fullProposalAbi = baseProposalAbi.concat(["function addSupport(uint256 amount)"]);
          const proposalContract = new ethers.Contract(
            proposalAddress,
            fullProposalAbi,
            signerRef.current
          );
          
          setIsLoading(true);
          showNotification('Adding support...', 'info');
          
          // Call the addSupport function
          const tx = await proposalContract.addSupport(amount);
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          await tx.wait();
          
          setIsLoading(false);
          showNotification('Support added successfully!', 'success');
          
          // Clear the input field
          inputField.value = '';
          
          // Check if the proposal now triggers an election
          try {
            const electionTriggered = await proposalContract.electionTriggered();
            if (electionTriggered) {
              showNotification('This proposal has triggered an election!', 'success');
            }
          } catch (error) {
            console.warn('Error checking election triggered status:', error);
          }
          
          // Clear cache for this proposal and reload
          delete proposalCacheRef.current[proposalAddress];
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error adding support:', error);
          setIsLoading(false);
          showNotification('Failed to add support: ' + (error.message || error), 'danger');
        }
      };
      
      // Vote on a proposal
      const voteOnProposal = async (proposalAddress, isYesVote) => {
        try {
          if (!signerRef.current) {
            showNotification('Please connect your wallet first', 'danger');
            return;
          }
          
          // Use cache to avoid making multiple RPC calls
          const proposal = proposalCacheRef.current[proposalAddress];
          if (!proposal) {
            showNotification('Proposal not found in cache, reloading data...', 'warning');
            await loadAllProposals();
            return;
          }
          
          // Create contract instance
          const proposalContract = new ethers.Contract(
            proposalAddress,
            baseProposalAbi,
            signerRef.current
          );
          
          // Check if the election is still active (using cached data to avoid RPC calls)
          if (!proposal.isActive) {
            showNotification(`This election is ${proposal.electionStatus.toLowerCase()}`, 'danger');
            return;
          }
          
          // Get the voting addresses from cache
          const yesVoteAddress = await proposalContract.yesVoteAddress();
          const noVoteAddress = await proposalContract.noVoteAddress();
          const votingTokenId = proposal.votingTokenId;
          
          // Determine vote destination
          const voteDestination = isYesVote ? yesVoteAddress : noVoteAddress;
          
          // Check if user has voting tokens (using cached data)
          const votingBalance = parseInt(proposal.votes.available);
          
          if (votingBalance === 0) {
            showNotification('You have no voting tokens for this proposal', 'danger');
            return;
          }
          
          // Get the vote amount from the input field
          const inputField = document.getElementById(`vote-amount-${proposalAddress}`);
          if (!inputField) {
            showNotification('Input field not found', 'danger');
            return;
          }
          
          const amount = parseInt(inputField.value);
          if (isNaN(amount) || amount <= 0) {
            showNotification('Please enter a valid amount', 'danger');
            return;
          }
          
          if (amount > votingBalance) {
            showNotification(`You only have ${votingBalance} voting tokens`, 'danger');
            return;
          }
          
          setIsLoading(true);
          showNotification(`Sending ${isYesVote ? 'YES' : 'NO'} vote...`, 'info');
          
          // Send voting tokens to the appropriate address
          const tx = await daoContractRef.current.safeTransferFrom(
            walletAddress,
            voteDestination,
            votingTokenId,
            amount,
            "0x" // No data
          );
          
          showNotification('Transaction submitted, waiting for confirmation...', 'info');
          
          // Wait for transaction confirmation
          await tx.wait();
          
          setIsLoading(false);
          showNotification(`Vote ${isYesVote ? 'YES' : 'NO'} cast successfully!`, 'success');
          
          // Clear the input field
          inputField.value = '';
          
          // Check if early termination is possible
          try {
            const earlyTerminationTx = await proposalContract.checkEarlyTermination();
            await earlyTerminationTx.wait();
          } catch (error) {
            // Early termination might not be applicable, so we just ignore errors
            console.log("Early termination check failed or not applicable:", error.message);
          }
          
          // Clear cache for this proposal and reload
          delete proposalCacheRef.current[proposalAddress];
          await loadAllProposals();
          
        } catch (error) {
          console.error('Error voting:', error);
          setIsLoading(false);
          showNotification('Failed to vote: ' + (error.message || error), 'danger');
        }
      };
      
      // Define DAO contract ABI
      const daoAbi = [
        "function name() view returns (string)",
        "function tokenPrice() view returns (uint256)",
        "function balanceOf(address account, uint256 id) view returns (uint256)",
        "function totalSupply(uint256 tokenId) view returns (uint256)",
        "function purchaseTokens() payable",
        "function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)",
        "function quorumPercentage() view returns (uint256)",
        "function supportThreshold() view returns (uint256)",
        "function vestedBalance(address holder) view returns (uint256)",
        "function vestingPeriod() view returns (uint256)"
      ];
      
      // Helper functions to update form data
      const updateTreasuryData = (field, value) => {
        const newData = Object.assign({}, treasuryData);
        newData[field] = value;
        setTreasuryData(newData);
      };
      
      const updateMintData = (field, value) => {
        const newData = Object.assign({}, mintData);
        newData[field] = value;
        setMintData(newData);
      };
      
      const updatePriceData = (field, value) => {
        const newData = Object.assign({}, priceData);
        newData[field] = value;
        setPriceData(newData);
      };
      
      // Define Factory contract ABI
      const factoryAbi = [
        "function proposalCount() view returns (uint256)",
        "function getProposal(uint256 index) view returns (address)",
        "function createResolutionProposal(string description) returns (address)",
        "function createTreasuryProposal(string description, address recipient, uint256 amount, address token, uint256 tokenId) returns (address)",
        "function createMintProposal(string description, address recipient, uint256 amount) returns (address)",
        "function createTokenPriceProposal(string description, uint256 newPrice) returns (address)"
      ];
        
      // Connect wallet
      const connectWallet = async () => {
        try {
          setIsLoading(true);
          
          // Check if MetaMask is installed
          if (typeof window.ethereum === 'undefined') {
            showNotification('Please install MetaMask to use this dApp', 'danger');
            setIsLoading(false);
            return;
          }
          
          // Request account access
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          const currentAccount = accounts[0];
          setWalletAddress(currentAccount);
          
          // Initialize ethers provider and signer
          // Use simpler network configuration to avoid connection issues
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          
          // Save references
          providerRef.current = provider;
          signerRef.current = signer;
          
          // Initialize contracts using the non-ENS signer
          const daoContract = new ethers.Contract(DAO_ADDRESS, daoAbi, signer);
          daoContractRef.current = daoContract;
          
          const factoryContract = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);
          factoryContractRef.current = factoryContract;
          
          try {
            // Set connected status first for better UI responsiveness
            setIsConnected(true);
            showNotification('Wallet connected successfully! Loading data...', 'success');
            
            // First try to get the treasury balance which doesn't require contract functions
            let treasuryBalance;
            try {
              treasuryBalance = await provider.getBalance(DAO_ADDRESS);
            } catch (balanceError) {
              console.warn("Error getting treasury balance:", balanceError);
              treasuryBalance = ethers.BigNumber.from(0);
            }
            
            // Now load contract data
            try {
              // Try getting network information first
              const network = await provider.getNetwork();
              console.log("Connected to network:", network);
              
              // Add a delay to give the provider time to fully connect
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Try individual reads with better error handling instead of Promise.all
              let daoName, tokenPrice, tokenBalance, vestedBal, tokenSupply, quorumPercentage, supportThreshold, vestingPer;

              try {
                daoName = await daoContract.name();
              } catch (e) {
                console.warn("Error getting DAO name:", e);
                daoName = "Market DAO";
              }

              try {
                tokenPrice = await daoContract.tokenPrice();
              } catch (e) {
                console.warn("Error getting token price:", e);
                tokenPrice = ethers.utils.parseEther("0.1");
              }

              try {
                tokenBalance = await daoContract.balanceOf(currentAccount, 0);
              } catch (e) {
                console.warn("Error getting token balance:", e);
                tokenBalance = ethers.BigNumber.from(100);
              }

              try {
                vestedBal = await daoContract.vestedBalance(currentAccount);
              } catch (e) {
                console.warn("Error getting vested balance:", e);
                vestedBal = ethers.BigNumber.from(100);
              }

              try {
                tokenSupply = await daoContract.totalSupply(0);
              } catch (e) {
                console.warn("Error getting token supply:", e);
                tokenSupply = ethers.BigNumber.from(1000);
              }

              try {
                quorumPercentage = await daoContract.quorumPercentage();
              } catch (e) {
                console.warn("Error getting quorum percentage:", e);
                quorumPercentage = ethers.BigNumber.from(25);
              }

              try {
                supportThreshold = await daoContract.supportThreshold();
              } catch (e) {
                console.warn("Error getting support threshold:", e);
                supportThreshold = ethers.BigNumber.from(15);
              }

              try {
                vestingPer = await daoContract.vestingPeriod();
              } catch (e) {
                console.warn("Error getting vesting period:", e);
                vestingPer = ethers.BigNumber.from(0);
              }

              const unvestedBal = tokenBalance.sub(vestedBal);

              setDaoInfo({
                name: daoName,
                tokenBalance: tokenBalance.toString(),
                vestedBalance: vestedBal.toString(),
                unvestedBalance: unvestedBal.toString(),
                tokenSupply: tokenSupply.toString(),
                tokenPrice: ethers.utils.formatEther(tokenPrice),
                quorumPercentage: quorumPercentage.toString(),
                supportThreshold: supportThreshold.toString(),
                treasuryBalance: treasuryBalance,
                vestingPeriod: vestingPer.toString()
              });
              
              // Try loading proposals with better error handling
              try {
                await loadAllProposals();
              } catch (proposalErr) {
                console.error("Failed to load proposals:", proposalErr);
                showNotification("Connected but could not load proposals. Check console for details.", "warning");
              }
            } catch (contractError) {
              console.error("Error loading contract data:", contractError);
              
              // Still set the treasury balance if we have it
              setDaoInfo({
                name: 'Market DAO',
                tokenBalance: '100',
                vestedBalance: '100',
                unvestedBalance: '0',
                tokenSupply: '1000',
                tokenPrice: '0.1',
                quorumPercentage: '25',
                supportThreshold: '15',
                treasuryBalance: treasuryBalance,
                vestingPeriod: '0'
              });
              
              showNotification('Connected, but there was an error loading some contract data', 'warning');
            }
          } catch (error) {
            console.error("Error in wallet connection process:", error);
            // Fallback to mock data if overall process fails
            setDaoInfo({
              name: 'Market DAO',
              tokenBalance: '100',
              vestedBalance: '100',
              unvestedBalance: '0',
              tokenSupply: '1000',
              tokenPrice: '0.1',
              quorumPercentage: '25',
              supportThreshold: '15',
              treasuryBalance: '0',
              vestingPeriod: '0'
            });
            setIsConnected(true);
            showNotification('Connected, but there was an error loading data', 'warning');
          }
          
          setIsLoading(false);
        } catch (error) {
          console.error('Error connecting wallet:', error);
          showNotification('Failed to connect wallet', 'danger');
          setIsLoading(false);
        }
      };
      
      // Render history proposal components with safe value handling
      const renderHistoryProposal = (proposal) => {
        // Set border color based on proposal type
        const borderColor = 
          proposal.type === 'treasury' ? '#4caf50' : 
          proposal.type === 'mint' ? '#ff9800' :
          proposal.type === 'price' ? '#2196f3' : '#9c27b0';
        
        // Set badge class based on proposal type
        const badgeClass = `badge badge-${proposal.type}`;
        
        // Set result style
        const resultStyle = {
          color: proposal.result === 'APPROVED' ? '#4caf50' : 
                proposal.result.includes('Quorum') ? '#ff9800' : '#f44336',
          fontWeight: 'bold'
        };
        
        // Safe rendering function for vote statistics
        const renderVoteStats = () => {
          try {
            const yesVotes = parseInt(safeValue(proposal.votes.yes)) || 0;
            const noVotes = parseInt(safeValue(proposal.votes.no)) || 0;
            const totalVotes = parseInt(safeValue(proposal.votes.total)) || 1; // Avoid division by zero
            const totalCast = yesVotes + noVotes;
            const turnoutPercent = Math.round((totalCast / totalVotes) * 100);
            
            return (
              <div className="small">
                <div><strong>Total Votes:</strong> {totalCast} of {safeValue(proposal.votes.total)}</div>
                <div><strong>Turnout:</strong> {isNaN(turnoutPercent) ? 0 : turnoutPercent}% 
                (Quorum: {safeValue(daoInfo.quorumPercentage)}% required)</div>
                {safeValue(proposal.votingTokenId) !== '0' && (
                  <div className="mt-2 text-center">
                    <strong>Voting token ID:</strong> {safeValue(proposal.votingTokenId)}
                  </div>
                )}
              </div>
            );
          } catch (error) {
            console.error('Error rendering vote statistics', error);
            return (
              <div className="text-danger small">Error calculating vote statistics</div>
            );
          }
        };
        
        // Safe rendering function for proposal details
        const renderProposalDetails = () => {
          try {
            switch(proposal.type) {
              case 'treasury':
                return (
                  <div className="bg-light p-3 rounded mb-3">
                    <div><strong>Recipient:</strong> {proposal.details && proposal.details.recipient && typeof proposal.details.recipient === 'string' 
                      ? `${proposal.details.recipient.substring(0, 6)}...${proposal.details.recipient.substring(38)}` 
                      : 'Invalid Address'}</div>
                    <div><strong>Amount:</strong> {proposal.details && proposal.details.token === ethers.constants.AddressZero 
                      ? `${safeFormatEther(proposal.details.amount)} ETH`
                      : `${safeValue(proposal.details && proposal.details.amount)} tokens`
                    }</div>
                    {proposal.details && proposal.details.token !== ethers.constants.AddressZero && proposal.details.token && (
                      <div><strong>Token:</strong> {typeof proposal.details.token === 'string' 
                        ? `${proposal.details.token.substring(0, 6)}...${proposal.details.token.substring(38)}` 
                        : 'Invalid Address'}</div>
                    )}
                    {proposal.details && proposal.details.tokenId !== '0' && (
                      <div><strong>Token ID:</strong> {safeValue(proposal.details.tokenId)}</div>
                    )}
                  </div>
                );
              case 'mint':
                return (
                  <div className="bg-light p-3 rounded mb-3">
                    <div><strong>Recipient:</strong> {proposal.details && proposal.details.recipient && typeof proposal.details.recipient === 'string' 
                      ? `${proposal.details.recipient.substring(0, 6)}...${proposal.details.recipient.substring(38)}` 
                      : 'Invalid Address'}</div>
                    <div><strong>Amount:</strong> {safeValue(proposal.details && proposal.details.amount)} tokens</div>
                  </div>
                );
              case 'price':
                return (
                  <div className="bg-light p-3 rounded mb-3">
                    <div><strong>New Price:</strong> {safeFormatEther(proposal.details && proposal.details.newPrice)} ETH</div>
                  </div>
                );
              default:
                return null;
            }
          } catch (error) {
            console.error('Error rendering proposal details', error);
            return (
              <div className="text-danger small">Error rendering proposal details</div>
            );
          }
        };
        
        return (
          <div key={proposal.address} className="card mb-3 proposal-card" style={{borderLeftColor: borderColor}}>
            <div className="card-body">
              <span className={badgeClass + " mb-2 d-inline-block text-uppercase small fw-bold px-2 py-1 rounded"}>
                {proposal.type} {proposal.result}
              </span>
              
              <h3 className="mb-2">{proposal.description}</h3>
              
              <div className="text-muted small mb-3">
                Proposer: {proposal.proposer && typeof proposal.proposer === 'string' 
                  ? `${proposal.proposer.substring(0, 6)}...${proposal.proposer.substring(38)}`
                  : 'Invalid Address'}
              </div>
              
              {/* Proposal type specific details */}
              {renderProposalDetails()}
              
              <div style={resultStyle} className="my-3">
                {proposal.result}: {safeValue(proposal.votes.yes)} Yes / {safeValue(proposal.votes.no)} No
              </div>
              
              {/* Vote statistics */}
              {renderVoteStats()}
            </div>
          </div>
        );
      };
      
      // Render the appropriate content based on active tab
      const renderContent = () => {
        if (!isConnected) {
          return (
            <div className="card shadow">
              <div className="card-body text-center p-5">
                <h2 className="mb-4">Welcome to Market DAO</h2>
                <p className="mb-4">Please connect your wallet to interact with the DAO</p>
                <button className="btn btn-primary btn-lg" onClick={connectWallet}>
                  Connect Wallet
                </button>
              </div>
            </div>
          );
        }
        
        switch (activeTab) {
          case 'dashboard':
            return (
              <>
                <div className="card shadow mb-4 mx-auto" style={{maxWidth: '700px'}}>
                  <div className="card-body">
                    <h2 className="card-title text-center mb-4">DAO Information</h2>
                    <div className="container" style={{maxWidth: '560px'}}>
                      <div className="row row-cols-1 row-cols-md-3 g-2 mb-3 justify-content-center">
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.name}</div>
                              <div className="text-muted small">DAO Name</div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.tokenBalance}</div>
                              <div className="text-muted small">Total Balance</div>
                              <div className="small">
                                <a
                                  href={`https://testnet.rarible.com/token/polygon/${DAO_ADDRESS}:0`}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="text-primary"
                                  style={{fontSize: '0.7rem'}}
                                >
                                  Buy/Sell
                                </a>
                              </div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-success bg-opacity-10 rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold text-success">{daoInfo.vestedBalance}</div>
                              <div className="text-muted small">Vested (Available)</div>
                              <div className="text-success" style={{fontSize: '0.65rem'}}>
                                Can vote & support
                              </div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-warning bg-opacity-10 rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold text-warning">{daoInfo.unvestedBalance}</div>
                              <div className="text-muted small">Unvested (Locked)</div>
                              <div className="text-warning" style={{fontSize: '0.65rem'}}>
                                {daoInfo.vestingPeriod !== '0' ? `${daoInfo.vestingPeriod} blocks` : 'No vesting'}
                              </div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.tokenSupply}</div>
                              <div className="text-muted small">Total Supply</div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.tokenPrice} ETH</div>
                              <div className="text-muted small">Token Price</div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.treasuryBalance ? safeFormatEther(daoInfo.treasuryBalance) : '0'} ETH</div>
                              <div className="text-muted small">Treasury</div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.quorumPercentage}%</div>
                              <div className="text-muted small">Quorum Requirement</div>
                            </div>
                          </div>
                        </div>
                        <div className="col">
                          <div className="bg-light rounded p-2" style={{height: '100%'}}>
                            <div className="text-center">
                              <div className="fw-bold">{daoInfo.supportThreshold}%</div>
                              <div className="text-muted small">Support Threshold</div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <h3 className="mb-3">Purchase Tokens</h3>
                    {Number(daoInfo.tokenPrice) === 0 ? (
                      <div className="alert alert-info">
                        <p className="mb-0">Direct token purchases are currently disabled (token price is set to 0).</p>
                      </div>
                    ) : (
                      <>
                        <div className="row g-3 align-items-end justify-content-center mb-3">
                          <div className="col-12 col-md-4">
                            <label htmlFor="purchase-amount" className="form-label">Amount</label>
                            <input 
                              type="number" 
                              className="form-control"
                              id="purchase-amount" 
                              min="1" 
                              value={purchaseAmount}
                              onChange={(e) => setPurchaseAmount(e.target.value)}
                              placeholder="Tokens to buy"
                            />
                          </div>
                          <div className="col-12 col-md-4">
                            <button 
                              className="btn btn-primary w-100"
                              onClick={purchaseTokens}
                            >
                              Purchase
                            </button>
                          </div>
                        </div>
                        <div className="text-center">
                          <p>Cost: {Number(purchaseAmount) * Number(daoInfo.tokenPrice)} ETH</p>
                        </div>
                      </>
                    )}
                  </div>
                </div>
                
                <div className="card shadow mx-auto" style={{maxWidth: '700px'}}>
                  <div className="card-body">
                    <h2 className="card-title mb-4">Create Proposal</h2>
                    
                    <div className="mb-4">
                      <label className="form-label text-center d-block">Proposal Type</label>
                      <div className="btn-group d-flex flex-wrap" role="group">
                        <button 
                          type="button" 
                          className={`btn ${proposalType === 'resolution' ? 'btn-primary' : 'btn-outline-primary'}`}
                          onClick={() => setProposalType('resolution')}
                        >
                          Resolution
                        </button>
                        <button 
                          type="button" 
                          className={`btn ${proposalType === 'treasury' ? 'btn-primary' : 'btn-outline-primary'}`}
                          onClick={() => setProposalType('treasury')}
                        >
                          Treasury
                        </button>
                        <button 
                          type="button" 
                          className={`btn ${proposalType === 'mint' ? 'btn-primary' : 'btn-outline-primary'}`}
                          onClick={() => setProposalType('mint')}
                        >
                          Mint Tokens
                        </button>
                        <button 
                          type="button" 
                          className={`btn ${proposalType === 'price' ? 'btn-primary' : 'btn-outline-primary'}`}
                          onClick={() => setProposalType('price')}
                        >
                          Token Price
                        </button>
                      </div>
                    </div>
                    
                    {proposalType === 'resolution' && (
                      <div>
                        <div className="mb-3">
                          <label htmlFor="proposal-description" className="form-label">Description</label>
                          <textarea 
                            className="form-control"
                            id="proposal-description" 
                            rows="4" 
                            value={proposalDescription}
                            onChange={(e) => setProposalDescription(e.target.value)}
                            placeholder="Enter proposal description"
                          ></textarea>
                        </div>
                        <div className="text-center">
                          <button className="btn btn-primary" onClick={createResolutionProposal}>Create Resolution Proposal</button>
                        </div>
                      </div>
                    )}
                    
                    {proposalType === 'treasury' && (
                      <div>
                        <div className="mb-3">
                          <label htmlFor="treasury-description" className="form-label">Description</label>
                          <textarea 
                            className="form-control"
                            id="treasury-description" 
                            rows="4" 
                            value={treasuryData.description}
                            onChange={(e) => updateTreasuryData('description', e.target.value)}
                            placeholder="Enter a description for this treasury transfer"
                          ></textarea>
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="treasury-recipient" className="form-label">Recipient Address</label>
                          <input 
                            type="text"
                            className="form-control" 
                            id="treasury-recipient" 
                            value={treasuryData.recipient}
                            onChange={(e) => updateTreasuryData('recipient', e.target.value)}
                            placeholder="0x..."
                          />
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="treasury-amount" className="form-label">Amount</label>
                          <input 
                            type="number"
                            className="form-control" 
                            id="treasury-amount" 
                            min="0" 
                            step="any" 
                            value={treasuryData.amount}
                            onChange={(e) => updateTreasuryData('amount', e.target.value)}
                            placeholder="Amount to transfer"
                          />
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="treasury-token-type" className="form-label">Token Type</label>
                          <select 
                            className="form-select"
                            id="treasury-token-type"
                            value={treasuryData.tokenType}
                            onChange={(e) => updateTreasuryData('tokenType', e.target.value)}
                          >
                            <option value="eth">ETH</option>
                            <option value="erc20">ERC20</option>
                            <option value="erc721">ERC721</option>
                            <option value="erc1155">ERC1155</option>
                          </select>
                        </div>
                        
                        {treasuryData.tokenType !== 'eth' && (
                          <div className="mb-3">
                            <label htmlFor="treasury-token-address" className="form-label">Token Address</label>
                            <input 
                              type="text"
                              className="form-control" 
                              id="treasury-token-address" 
                              value={treasuryData.tokenAddress}
                              onChange={(e) => updateTreasuryData('tokenAddress', e.target.value)}
                              placeholder="0x..."
                            />
                          </div>
                        )}
                        
                        {(treasuryData.tokenType === 'erc721' || treasuryData.tokenType === 'erc1155') && (
                          <div className="mb-3">
                            <label htmlFor="treasury-token-id" className="form-label">Token ID</label>
                            <input 
                              type="number"
                              className="form-control" 
                              id="treasury-token-id" 
                              min="0" 
                              step="1" 
                              value={treasuryData.tokenId}
                              onChange={(e) => updateTreasuryData('tokenId', e.target.value)}
                              placeholder="Token ID"
                            />
                          </div>
                        )}
                        
                        <div className="text-center">
                          <button className="btn btn-primary" onClick={createTreasuryProposal}>Create Treasury Proposal</button>
                        </div>
                      </div>
                    )}
                    
                    {proposalType === 'mint' && (
                      <div>
                        <div className="mb-3">
                          <label htmlFor="mint-description" className="form-label">Description</label>
                          <textarea 
                            className="form-control"
                            id="mint-description" 
                            rows="4" 
                            value={mintData.description}
                            onChange={(e) => updateMintData('description', e.target.value)}
                            placeholder="Enter a description for minting new tokens"
                          ></textarea>
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="mint-recipient" className="form-label">Recipient Address</label>
                          <input 
                            type="text"
                            className="form-control" 
                            id="mint-recipient" 
                            value={mintData.recipient}
                            onChange={(e) => updateMintData('recipient', e.target.value)}
                            placeholder="0x..."
                          />
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="mint-amount" className="form-label">Amount</label>
                          <input 
                            type="number"
                            className="form-control" 
                            id="mint-amount" 
                            min="1" 
                            step="1" 
                            value={mintData.amount}
                            onChange={(e) => updateMintData('amount', e.target.value)}
                            placeholder="Number of tokens to mint"
                          />
                        </div>
                        
                        <div className="text-center">
                          <button className="btn btn-primary" onClick={createMintProposal}>Create Mint Proposal</button>
                        </div>
                      </div>
                    )}
                    
                    {proposalType === 'price' && (
                      <div>
                        <div className="mb-3">
                          <label htmlFor="price-description" className="form-label">Description</label>
                          <textarea 
                            className="form-control"
                            id="price-description" 
                            rows="4" 
                            value={priceData.description}
                            onChange={(e) => updatePriceData('description', e.target.value)}
                            placeholder="Enter a description for changing the token price"
                          ></textarea>
                        </div>
                        
                        <div className="mb-3">
                          <label htmlFor="new-token-price" className="form-label">New Token Price (in ETH)</label>
                          <input 
                            type="number"
                            className="form-control" 
                            id="new-token-price" 
                            min="0" 
                            step="any" 
                            value={priceData.newPrice}
                            onChange={(e) => updatePriceData('newPrice', e.target.value)}
                            placeholder="Enter new token price (0 to disable direct sales)"
                          />
                        </div>
                        
                        <div className="text-center">
                          <button className="btn btn-primary" onClick={createTokenPriceProposal}>Create Token Price Proposal</button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </>
            );
            
          case 'proposals':
            return (
              <div className="card shadow mx-auto" style={{maxWidth: '700px'}}>
                <div className="card-body">
                  <h2 className="card-title mb-4">Active Proposals</h2>
                  {proposals.length === 0 ? (
                    <p className="text-center">No active proposals found.</p>
                  ) : (
                    proposals.map(proposal => {
                      // Set border color based on proposal type
                      const borderColor = 
                        proposal.type === 'treasury' ? '#4caf50' : 
                        proposal.type === 'mint' ? '#ff9800' :
                        proposal.type === 'price' ? '#2196f3' : '#9c27b0';
                      
                      // Set badge class based on proposal type
                      const badgeClass = `badge badge-${proposal.type}`;
                      
                      return (
                        <div key={proposal.address} className="card mb-3 proposal-card" style={{borderLeftColor: borderColor}}>
                          <div className="card-body">
                            <span className={badgeClass + " mb-2 d-inline-block text-uppercase small fw-bold px-2 py-1 rounded"}>
                              {proposal.type}
                            </span>
                            
                            <h3 className="mb-2">{proposal.description}</h3>
                            
                            <div className="text-muted small mb-3">
                              Proposer: {proposal.proposer.substring(0, 6)}...{proposal.proposer.substring(38)}
                            </div>
                            
                            {/* Proposal type specific details */}
                            {proposal.type === 'treasury' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>Recipient:</strong> {proposal.details.recipient.substring(0, 6)}...{proposal.details.recipient.substring(38)}</div>
                                <div><strong>Amount:</strong> {proposal.details.token === ethers.constants.AddressZero 
                                  ? safeFormatEther(proposal.details.amount) + ' ETH'
                                  : safeValue(proposal.details.amount) + ' tokens'
                                }</div>
                                {proposal.details.token !== ethers.constants.AddressZero && (
                                  <div><strong>Token:</strong> {proposal.details.token.substring(0, 6)}...{proposal.details.token.substring(38)}</div>
                                )}
                                {proposal.details.tokenId !== '0' && (
                                  <div><strong>Token ID:</strong> {safeValue(proposal.details.tokenId)}</div>
                                )}
                              </div>
                            )}
                            
                            {proposal.type === 'mint' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>Recipient:</strong> {proposal.details.recipient.substring(0, 6)}...{proposal.details.recipient.substring(38)}</div>
                                <div><strong>Amount:</strong> {safeValue(proposal.details.amount)} tokens</div>
                              </div>
                            )}
                            
                            {proposal.type === 'price' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>New Price:</strong> {safeFormatEther(proposal.details.newPrice)} ETH</div>
                              </div>
                            )}
                            
                            <div className="d-flex justify-content-between mb-3">
                              <div>Created at block: {proposal.createdAt}</div>
                              <div>Current support: {proposal.supportTotal}</div>
                            </div>
                            
                            <div className="row g-3 justify-content-center align-items-center">
                              <div className="col-12 col-md-6">
                                <input 
                                  type="number" 
                                  className="form-control"
                                  placeholder="Support tokens" 
                                  id={`support-amount-${proposal.address}`}
                                />
                              </div>
                              <div className="col-12 col-md-6">
                                <button 
                                  className="btn btn-primary w-100"
                                  onClick={() => addSupport(proposal.address)}
                                >
                                  Add Support
                                </button>
                              </div>
                            </div>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
            );
            
          case 'elections':
            return (
              <div className="card shadow mx-auto" style={{maxWidth: '700px'}}>
                <div className="card-body">
                  <h2 className="card-title mb-4">Active Elections</h2>
                  {electionProposals.length === 0 ? (
                    <p className="text-center">No active elections found.</p>
                  ) : (
                    electionProposals.map(proposal => {
                      // Set border color based on proposal type
                      const borderColor = 
                        proposal.type === 'treasury' ? '#4caf50' : 
                        proposal.type === 'mint' ? '#ff9800' :
                        proposal.type === 'price' ? '#2196f3' : '#9c27b0';
                      
                      // Set badge class based on proposal type
                      const badgeClass = `badge badge-${proposal.type}`;
                      
                      // Calculate vote percentages
                      const yesPercent = proposal.votes.total > 0 
                        ? Math.round((parseInt(proposal.votes.yes) / parseInt(proposal.votes.total)) * 100)
                        : 0;
                        
                      const noPercent = proposal.votes.total > 0 
                        ? Math.round((parseInt(proposal.votes.no) / parseInt(proposal.votes.total)) * 100)
                        : 0;
                        
                      const turnoutPercent = proposal.votes.total > 0
                        ? Math.round(((parseInt(proposal.votes.yes) + parseInt(proposal.votes.no)) / parseInt(proposal.votes.total)) * 100)
                        : 0;
                        
                      // Status alert class
                      const statusClass = proposal.isActive 
                        ? 'success'
                        : (proposal.electionStatus === "Not Started" ? 'primary' : 'danger');
                        
                      const statusText = proposal.isActive 
                        ? 'Election ACTIVE - Cast your votes before the voting period ends.'
                        : (proposal.electionStatus === "Not Started" 
                          ? 'Election has not started yet. Voting will be enabled soon.'
                          : 'Election has ENDED. No more votes can be cast.');
                      
                      return (
                        <div key={proposal.address} className="card mb-3 proposal-card" style={{borderLeftColor: borderColor}}>
                          <div className="card-body">
                            <span className={badgeClass + " mb-2 d-inline-block text-uppercase small fw-bold px-2 py-1 rounded"}>
                              {proposal.type} ELECTION
                            </span>
                            
                            <h3 className="mb-2">{proposal.description}</h3>
                            
                            <div className="text-muted small mb-3">
                              Proposer: {proposal.proposer.substring(0, 6)}...{proposal.proposer.substring(38)}
                            </div>
                            
                            {/* Proposal type specific details */}
                            {proposal.type === 'treasury' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>Recipient:</strong> {proposal.details.recipient.substring(0, 6)}...{proposal.details.recipient.substring(38)}</div>
                                <div><strong>Amount:</strong> {proposal.details.token === ethers.constants.AddressZero 
                                  ? safeFormatEther(proposal.details.amount) + ' ETH'
                                  : safeValue(proposal.details.amount) + ' tokens'
                                }</div>
                                {proposal.details.token !== ethers.constants.AddressZero && (
                                  <div><strong>Token:</strong> {proposal.details.token.substring(0, 6)}...{proposal.details.token.substring(38)}</div>
                                )}
                                {proposal.details.tokenId !== '0' && (
                                  <div><strong>Token ID:</strong> {safeValue(proposal.details.tokenId)}</div>
                                )}
                              </div>
                            )}
                            
                            {proposal.type === 'mint' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>Recipient:</strong> {proposal.details.recipient.substring(0, 6)}...{proposal.details.recipient.substring(38)}</div>
                                <div><strong>Amount:</strong> {safeValue(proposal.details.amount)} tokens</div>
                              </div>
                            )}
                            
                            {proposal.type === 'price' && (
                              <div className="bg-light p-3 rounded mb-3">
                                <div><strong>New Price:</strong> {safeFormatEther(proposal.details.newPrice)} ETH</div>
                              </div>
                            )}
                            
                            <div className="d-flex justify-content-between mb-3">
                              <div>Created at block: {proposal.createdAt}</div>
                              <div>Support threshold: {proposal.supportTotal}</div>
                            </div>
                            
                            {/* Vote Progress Bar */}
                            <div className="mb-4">
                              <div className="d-flex justify-content-between mb-2">
                                <div><strong>Yes:</strong> {proposal.votes.yes} ({yesPercent}%)</div>
                                <div><strong>No:</strong> {proposal.votes.no} ({noPercent}%)</div>
                              </div>
                              <div className="text-center mb-2 small">
                                <strong>Total Votes:</strong> {parseInt(proposal.votes.yes) + parseInt(proposal.votes.no)} of {proposal.votes.total} 
                                ({turnoutPercent}% turnout)
                                <div><strong>Quorum Requirement:</strong> {daoInfo.quorumPercentage}% participation needed for valid result</div>
                              </div>
                              <div className="progress mb-2" style={{height: "20px"}}>
                                <div 
                                  className="progress-bar bg-success" 
                                  role="progressbar" 
                                  style={{width: `${yesPercent}%`}} 
                                  aria-valuenow={yesPercent} 
                                  aria-valuemin="0" 
                                  aria-valuemax="100"
                                ></div>
                                <div 
                                  className="progress-bar bg-danger" 
                                  role="progressbar" 
                                  style={{width: `${noPercent}%`}} 
                                  aria-valuenow={noPercent} 
                                  aria-valuemin="0" 
                                  aria-valuemax="100"
                                ></div>
                              </div>
                              <div className="text-center small text-muted">
                                Voting token ID: {proposal.votingTokenId} 
                                <div>
                                  <a 
                                    href={`https://testnet.rarible.com/token/polygon/${DAO_ADDRESS}:${proposal.votingTokenId}`}
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    className="text-primary"
                                  >
                                    Buy/Sell on Rarible
                                  </a>
                                </div>
                              </div>
                            </div>
                            
                            <div className="mb-3">
                              <label htmlFor={`vote-amount-${proposal.address}`} className="form-label text-center d-block">
                                Vote Amount: <span className="text-muted fw-normal">
                                  (You have {proposal.votes.available} tokens available)
                                </span>
                              </label>
                              <div className="row g-3 justify-content-center">
                                <div className="col-12 col-md-6">
                                  <input 
                                    type="number" 
                                    className="form-control"
                                    id={`vote-amount-${proposal.address}`}
                                    placeholder="Tokens to vote" 
                                    max={proposal.votes.available}
                                  />
                                </div>
                              </div>
                            </div>
                            
                            <div className="row g-3">
                              <div className="col">
                                <button 
                                  className={`btn btn-success w-100 ${!proposal.isActive ? 'disabled' : ''}`}
                                  onClick={() => voteOnProposal(proposal.address, true)}
                                  title={proposal.isActive ? "Vote in favor of this proposal" : "Voting not available"}
                                  disabled={!proposal.isActive}
                                >
                                  Vote Yes
                                </button>
                              </div>
                              <div className="col">
                                <button 
                                  className={`btn btn-danger w-100 ${!proposal.isActive ? 'disabled' : ''}`}
                                  onClick={() => voteOnProposal(proposal.address, false)}
                                  title={proposal.isActive ? "Vote against this proposal" : "Voting not available"}
                                  disabled={!proposal.isActive}
                                >
                                  Vote No
                                </button>
                              </div>
                            </div>
                            
                            {/* Election status message */}
                            <div className={`alert alert-${statusClass} mt-3 mb-0 text-center small`}>
                              {statusText}
                            </div>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
            );
            
          case 'history':
            return (
              <div className="card shadow mx-auto" style={{maxWidth: '700px'}}>
                <div className="card-body">
                  <h2 className="card-title mb-4">Proposal History</h2>
                  {historyProposals.length === 0 ? (
                    <p className="text-center">No proposal history found.</p>
                  ) : (
                    historyProposals.map(proposal => renderHistoryProposal(proposal))
                  )}
                </div>
              </div>
            );
            
          default:
            return null;
        }
      };
      
      return (
        <>
          <h1 className="text-center mb-4">Market DAO</h1>
          
          {isConnected && (
            <ul className="nav nav-tabs nav-fill mb-4">
              <li className="nav-item">
                <a 
                  className={`nav-link ${activeTab === 'dashboard' ? 'active' : ''}`}
                  href="#" 
                  onClick={(e) => { e.preventDefault(); setActiveTab('dashboard'); }}
                >
                  Dashboard
                </a>
              </li>
              <li className="nav-item">
                <a 
                  className={`nav-link ${activeTab === 'proposals' ? 'active' : ''}`}
                  href="#" 
                  onClick={(e) => { e.preventDefault(); setActiveTab('proposals'); }}
                >
                  Proposals
                </a>
              </li>
              <li className="nav-item">
                <a 
                  className={`nav-link ${activeTab === 'elections' ? 'active' : ''}`}
                  href="#" 
                  onClick={(e) => { e.preventDefault(); setActiveTab('elections'); }}
                >
                  Elections
                </a>
              </li>
              <li className="nav-item">
                <a 
                  className={`nav-link ${activeTab === 'history' ? 'active' : ''}`}
                  href="#" 
                  onClick={(e) => { e.preventDefault(); setActiveTab('history'); }}
                >
                  History
                </a>
              </li>
            </ul>
          )}
          
          {renderContent()}
          
          {/* Loading overlay */}
          {isLoading && (
            <div className="position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center" 
              style={{
                backgroundColor: 'rgba(0, 0, 0, 0.5)',
                zIndex: 1050
              }}>
              <div className="bg-white p-4 rounded shadow text-center">
                <div className="spinner mx-auto mb-3"></div>
                <div className="fw-bold">Processing Blockchain Request...</div>
                <div className="text-muted small">Please wait for completion</div>
              </div>
            </div>
          )}
          
          {notification.show && (
            <div 
              className={`position-fixed bottom-0 end-0 m-3 p-3 alert alert-${notification.type}`}
              style={{zIndex: 1051}}
            >
              {notification.message}
            </div>
          )}
          
          {/* Footer with GitHub link */}
          <div className="mt-5 pt-3 text-center border-top text-muted small">
            <a 
              href="https://github.com/evronm/marketDAO" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-decoration-none"
            >
              What's this? View the GitHub repository
            </a>
          </div>
        </>
      );
    }
    
    // Render the App
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
